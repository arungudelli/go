+++
title = "HTML Tokenizer Vulnerability Fixed in Go's `x/net/html`"
date = "2025-04-07T00:00:00+00:00"
lastmod = "2025-04-07T00:00:00+00:00"
description = "Recently, the Go team fixed a security vulnerability in the `golang.org/x/net/html` package. Version v0.38.0 of `golang.org/x/net` was tagged to address this issue."
draft = "false"
link = "HTML Tokenizer Vulnerability Fix"
image= "images/featured/golangpostimage.png"
enableToc= true
author="arungudelli"

+++

Recently, the Go team fixed a security vulnerability in the `golang.org/x/net/html` package.

Version **v0.38.0** of `golang.org/x/net` was tagged to address this issue.

This version fixes a vulnerability where the HTML tokenizer could emit incorrect tokens and cause the parser to produce an incorrect DOM. 

Specifically, the tokenizer incorrectly interpreted tags with **unquoted attribute values that end with a solidus character (`/`)** as self-closing. 

As a result, content following such tags could be placed in the wrong scope during DOM construction.

- This issue could affect **any tag** when using the `Tokenizer` directly.
- It also affected **tags inside foreign content contexts** (like `<svg>` and `<math>`) when using `html.Parse`, `ParseFragment`, `ParseFragmentWithOption`, or `ParseWithOptions`.

Thanks to Sean Ng (https://ensy.zip) for reporting this issue.

This is **CVE-2025-22872** and is tracked as [Go issue #73070](https://go.dev/issue/73070).

---

## üî¢ A Simple Example

To understand the issue better, consider the following basic HTML:

```html
<p a=/>hello</p>
```

### ‚ùå Before the Fix:
This would be misinterpreted as:
```html
<p a="/"></p>
hello
```
Which means the `<p>` tag is considered self-closing, and "hello" is parsed as content outside the `<p>` element.

### ‚úÖ After the Fix:
It is now correctly parsed as:
```html
<p a="/">hello</p>
```
"hello" is correctly placed inside the `<p>` tag.

---

## üìä Reproducing the Bug with `html.Tokenizer`

This issue can be observed directly using the low-level `html.Tokenizer`. 

Here‚Äôs an example that demonstrates how it misclassifies `<p a=/>` as self-closing before the fix.

```go
package main

import (
	"fmt"
	"golang.org/x/net/html"
	"strings"
)

func main() {
	const input = `<p a=/>hello</p>`

	tokenizer := html.NewTokenizer(strings.NewReader(input))

	for {
		tt := tokenizer.Next()
		if tt == html.ErrorToken {
			break
		}

		token := tokenizer.Token()

		switch tt {
		case html.StartTagToken:
			fmt.Printf("Start tag: <%s>\n", token.Data)
			for _, attr := range token.Attr {
				fmt.Printf("  Attr: %s = %q\n", attr.Key, attr.Val)
			}
		case html.SelfClosingTagToken:
			fmt.Printf("Self-closing tag: <%s />\n", token.Data)
			for _, attr := range token.Attr {
				fmt.Printf("  Attr: %s = %q\n", attr.Key, attr.Val)
			}
		case html.EndTagToken:
			fmt.Printf("End tag: </%s>\n", token.Data)
		case html.TextToken:
			fmt.Printf("Text: %q\n", token.Data)
		}
	}
}
```

### ‚ùå Output Before the Fix:
```
Self-closing tag: <p />
  Attr: a = "/"
Text: "hello"
End tag: </p>
```

### ‚úÖ Output After the Fix:
```
Start tag: <p>
  Attr: a = "/"
Text: "hello"
End tag: </p>
```

---

### üîç Clarifying Tokenizer Behavior vs. DOM Parsing

When you use `html.Tokenizer`, you're manually consuming a flat stream of tokens. 

There's **no DOM tree being built**.

If the tokenizer emits a `SelfClosingTagToken`, it simply means:
> "This tag appears to be self-closing based on its syntax."

But since you're not constructing a DOM, the tokenizer will still emit the next text token regardless of that classification. 

It does not understand or enforce what content belongs inside which tag.

So even if a tag like `<p a=/>` is misinterpreted as self-closing, you will still see:
```
Self-closing tag: <p />
  Attr: a = "/"
Text: "hello"
End tag: </p>
```

‚úÖ The real issue becomes impactful when using `html.Parse()` ‚Äî because the parser uses the token types to **build a DOM structure**. 

If a tag is misclassified as self-closing, the parser will close it immediately, and any following content (like `hello`) will be incorrectly placed **outside** the tag.

That‚Äôs what causes bugs like misplaced children or unexpected layouts in parsed HTML documents.

Let‚Äôs look at how that happens in the DOM parser next.

---

## üìä Reproducing the Bug with `html.Parse` in Foreign Context

The issue is also visible during full DOM parsing, especially when parsing foreign content (like SVG). Here's an example:

```go
package main

import (
	"fmt"
	"golang.org/x/net/html"
	"strings"
)

func main() {
	const input = `<svg><foo a=/>text</foo></svg>`

	doc, err := html.Parse(strings.NewReader(input))
	if err != nil {
		panic(err)
	}

	printDOM(doc, 0)
}

func printDOM(n *html.Node, depth int) {
	indent := strings.Repeat("  ", depth)
	switch n.Type {
	case html.ElementNode:
		fmt.Printf("%s<%s", indent, n.Data)
		for _, attr := range n.Attr {
			fmt.Printf(" %s=\"%s\"", attr.Key, attr.Val)
		}
		fmt.Println(">")
	case html.TextNode:
		fmt.Printf("%s%s\n", indent, n.Data)
	}

	for c := n.FirstChild; c != nil; c = c.NextSibling {
		printDOM(c, depth+1)
	}

	if n.Type == html.ElementNode {
		fmt.Printf("%s</%s>\n", indent, n.Data)
	}
}
```

### ‚ùå Output Before the Fix (v0.37.0):
```
  <html>
    <head>
    </head>
    <body>
      <svg>
        <foo a="/">
        </foo>
        text
      </svg>
    </body>
  </html>
```

### ‚úÖ Output After the Fix (v0.38.0):
```
  <html>
    <head>
    </head>
    <body>
      <svg>
        <foo a="/">
          text
        </foo>
      </svg>
    </body>
  </html>
```

The fix ensures correct nesting and DOM structure inside foreign contexts.

---

## üîß Technical Fix Summary

The fix was made in the `readStartTag` function. Previously, the code checked if a `/` occurred before the tag's closing `>`, and assumed that meant the tag was self-closing. 

The new logic checks whether that `/` is actually part of the last attribute's unquoted value.

This ensures that tags like `<p a=/>` or `<foo a=/>` are no longer incorrectly treated as self-closing.

---

## üìÜ Who Is Affected?
- Anyone using `golang.org/x/net/html.Tokenizer` directly.
- Anyone parsing foreign content with `html.Parse()` or similar functions (`ParseFragment`, etc.).

---

## üöÄ How to Fix It
To make sure you‚Äôre using the patched version, update your project:

```bash
go get golang.org/x/net@v0.38.0
```

Then run:
```bash
go mod tidy
```

---

## üìÑ Final Thoughts
Bugs in HTML parsers are easy to overlook but can have a large impact on web rendering, sanitization, and security.

This fix brings Go's HTML parser more in line with expected behavior and ensures developers can rely on accurate DOM generation even in edge cases.

Big thanks again to Sean Ng for reporting this issue and to the Go team for promptly resolving it.

Stay safe and keep your Go modules updated!